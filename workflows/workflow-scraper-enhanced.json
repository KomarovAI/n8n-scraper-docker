{"name": "Smart Web Scraper - Production v3 (Safe)", "active": false, "nodes": [{"parameters": {"httpMethod": "POST","path": "scrape","authentication": "headerAuth","options": {}}, "name": "Webhook (Header Auth)","type": "n8n-nodes-base.webhook","position": [250,300],"webhookId": "scraper-webhook","credentials": {"httpHeaderAuth": {"id": "1","name": "Scraper API Key"}}},{"parameters": {"functionCode": "// ENHANCED INPUT VALIDATION + SSRF PROTECTION (safe, with IP check)\nconst urls = Array.isArray($json.urls) ? $json.urls : [$json.url];\nconst selector = $json.selector || 'main, article, .content, body';\nconst waitFor = $json.waitFor;\nconst extractImages = $json.extractImages || false;\nfunction isIPBlocked(host) {\n  // Block local, private, metadata IPs\n  const blockedRegex = /^(127|10|192\\.168|172\\.(1[6-9]|2[0-9]|3[01])|0\\.|169\\.254|::1)/;\n  if (blockedRegex.test(host) || host === 'localhost') return true;\n  return false;\n}\nconst blockedHosts = [\"metadata.google.internal\", \"metadata.azure.com\"]\n\nconst validUrls = [];\nconst invalidUrls = [];\nfor (const url of urls) {\n  try {\n    if (!url || !url.startsWith('http')) {\n      invalidUrls.push({ url, reason: 'Invalid URL format' });\n      continue;\n    }\n    const urlObj = new URL(url);\n    if (isIPBlocked(urlObj.hostname) || blockedHosts.some(blocked=>urlObj.hostname.includes(blocked))) {\n      invalidUrls.push({ url, reason: 'SSRF/IP detected - blocked host' });\n      continue;\n    }\n    const needsJS = ['javascript','react','vue','angular','spa','ajax'].some(keyword=>url.toLowerCase().includes(keyword));\n    const isProtected = ['cloudflare','datadome','akamai','captcha'].some(keyword=>url.toLowerCase().includes(keyword));\n    validUrls.push({\n      url, selector, waitFor, extractImages, needsJS, isProtected,\n      requestId: `scrape-${Date.now()}-${validUrls.length}`,\n      timestamp: new Date().toISOString()\n    });\n  } catch (error) {\n    invalidUrls.push({ url, reason: error.message });\n  }\n}\nif (validUrls.length === 0) {\n  throw new Error('No valid URLs to scrape');\n}\nreturn { json: { validUrls, invalidUrls, total: urls.length, valid: validUrls.length, invalid: invalidUrls.length } };"}, "name": "Input Validator (Enhanced)","type": "n8n-nodes-base.code","position": [450,300]}, {"parameters": {"functionCode": "// SMART SAFE BATCH SPLITTING\nconst validUrls = $json.validUrls;\nconst MAX_CONCURRENT_TABS = 5;\nconst DELAY_BETWEEN_BATCHES = 3000;\nconst DELAY_BETWEEN_REQUESTS = 500;\nconst RANDOMIZE_DELAYS = true;\nfunction calcDelay(baseDelay, randomize=false){\n  if(!randomize)return baseDelay;\n  const variance=0.3;const min=baseDelay*(1-variance),max=baseDelay*(1+variance);\n  return Math.floor(Math.random()*(max-min+1))+min;\n}\nconst batches = [];\nfor(let i=0;i<validUrls.length;i+=MAX_CONCURRENT_TABS){\n  batches.push({\n    batchId: Math.floor(i/MAX_CONCURRENT_TABS)+1,\n    urls: validUrls.slice(i,i+MAX_CONCURRENT_TABS),\n    batchSize: Math.min(MAX_CONCURRENT_TABS, validUrls.length-i),\n    delay: calcDelay(DELAY_BETWEEN_BATCHES*(Math.floor(i/MAX_CONCURRENT_TABS)), RANDOMIZE_DELAYS)\n  });\n}\nreturn batches.map(batch=>({json:batch}));"}, "name": "Smart Batch Splitting (Safe)","type": "n8n-nodes-base.code","position": [650,300]}, {"parameters": {"conditions":{"boolean":[{"value1":"={{$json.urls[0].isProtected}}","value2":true}]}},"name":"Protected Site?","type":"n8n-nodes-base.if","position":[850,300]}, {"parameters":{"url":"https://api.github.com/repos/{{$env.GITHUB_OWNER}}/{{$env.GITHUB_REPO}}/actions/workflows/nodriver-batch.yml/dispatches","authentication":"predefinedCredentialType","nodeCredentialType":"githubApi","sendBody":true,"bodyParameters":{"parameters":[{"name":"ref","value":"main"},{"name":"inputs","value":"={{JSON.stringify({urls: $json.urls, batchId: $json.batchId})}}"}]},"options":{"timeout":120000}}, "name":"Trigger Nodriver Batch (GitHub Actions)","type":"n8n-nodes-base.httpRequest","position":[1050,200],"credentials":{"githubApi":{"id":"2","name":"GitHub API"}}}, {"parameters":{"conditions":{"boolean":[{"value1":"={{$json.urls[0].needsJS}}","value2":true}]}},"name":"Needs JavaScript?","type":"n8n-nodes-base.if","position":[1050,350]}, {"parameters":{"url":"https://api.github.com/repos/{{$env.GITHUB_OWNER}}/{{$env.GITHUB_REPO}}/actions/workflows/playwright-batch.yml/dispatches","authentication":"predefinedCredentialType","nodeCredentialType":"githubApi","sendBody":true,"bodyParameters":{"parameters":[{"name":"ref","value":"main"},{"name":"inputs","value":"={{JSON.stringify({urls: $json.urls, batchId: $json.batchId})}}"}]}}, "name":"Trigger Playwright Batch (GitHub Actions)","type":"n8n-nodes-base.httpRequest","position":[1250,300]}, {"parameters": {"functionCode":"// SMART BASIC HTTP BATCH (SAFE)\nconst urls = $json.urls;\nconst results = [];\nfor(const urlData of urls){\n  try{\n    const response=await this.helpers.httpRequest({method:'GET',url:urlData.url,timeout:30000,headers:{'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0','Accept':'text/html,application/xhtml+xml'}});\n    results.push({url:urlData.url,success:true,html:response.body.substring(0,100000),status:response.statusCode,runner:'http_basic',requestId:urlData.requestId});\n  }catch(error){\n    results.push({url:urlData.url,success:false,error:error.message,runner:'http_basic',requestId:urlData.requestId});\n  }\n}\nreturn {json:{results,batchId:$json.batchId}};"}, "name": "Basic HTTP Batch (Safe)","type": "n8n-nodes-base.code","position": [1250,450]}, {"parameters": {"functionCode":"// ENHANCED POLLING with CIRCUIT BREAKER\nconst batchId=$json.batchId;const MAX_POLL_TIME=300000;const maxAttempts=30;let totalElapsed=0;const baseDelay=20000;for(let i=0;i<maxAttempts;i++){const delay=Math.min(baseDelay*Math.pow(1.2,i),60000);if(totalElapsed>MAX_POLL_TIME)throw new Error('Polling circuit breaker - over 300s');await new Promise(res=>setTimeout(res,delay));totalElapsed+=delay;try{const response=await this.helpers.httpRequest({method:'GET',url:`https://api.github.com/repos/${process.env.GITHUB_OWNER}/${process.env.GITHUB_REPO}/actions/artifacts`,headers:{'Authorization':`Bearer ${process.env.GITHUB_TOKEN}`,'Accept':'application/vnd.github+json'}});const artifact=response.body.artifacts.find(a=>a.name.includes(`batch-${batchId}`));if(artifact){return{json:{status:'completed',artifactUrl:artifact.archive_download_url,artifactId:artifact.id,batchId,attempts:i+1,totalWaitTime:totalElapsed}};}}catch(error){console.log(`Polling attempt ${i+1} failed: ${error.message}`);}}throw new Error(`Timeout: batch ${batchId} did not complete in 5 minutes`);"}, "name":"Poll GitHub Actions Status (Safe)","type":"n8n-nodes-base.code","position":[1450,250]}, {"parameters":{"url":"={{$json.artifactUrl}}","authentication":"predefinedCredentialType","nodeCredentialType":"githubApi","options":{"response":{"response":{"responseFormat":"file"}}}},"name":"Download Artifact","type":"n8n-nodes-base.httpRequest","position":[1650,250]}, {"parameters":{"functionCode":"// PARSE ARTIFACT & EXTRACT RESULTS\nconst binaryData = await this.helpers.getBinaryDataBuffer(0);\nconst results = JSON.parse(binaryData.toString());\nreturn {json:{batchId:$json.batchId,results:results.successful||[],failed:results.failed||[],stats:{total:(results.successful?.length||0)+(results.failed?.length||0),successful:results.successful?.length||0,failed:results.failed?.length||0}}};"}, "name":"Parse Results","type":"n8n-nodes-base.code","position":[1850,300]}, {"parameters":{"functionCode":"// NATIVE CONTENT EXTRACTION (SAFE)\nconst items = $input.all();const extracted=[];for(const item of items){const results=item.json.results||[item.json];for(const result of results){if(!result.success||!result.html)continue;try{const mainRegex=/<main.*?>([\\s\\S]+?)<\\/main>/i;const articleRegex=/<article.*?>([\\s\\S]+?)<\\/article>/i;const bodyRegex=/<body.*?>([\\s\\S]+?)<\\/body>/i;let mainContent=mainRegex.exec(result.html)?.[1]||articleRegex.exec(result.html)?.[1]||bodyRegex.exec(result.html)?.[1]||result.html;mainContent=mainContent.replace(/[\\s]+/g,' ').replace(/\\n+/g,'\\n').trim().substring(0,50000);const title=/\\<title\\>(.*?)<\\/title\\>/i.exec(result.html)?.[1]||'';const description=/<meta name=\\\"description\\\" content=\\\"(.*?)\\\"\\/>/i.exec(result.html)?.[1]||'';const links=[];const linkRegex=/<a[^>]*href=\\\"([^\"]+)\\\"[^>]*>(.*?)<\\/a>/gi;let m;let count=0;while((m=linkRegex.exec(result.html))!==null&&count<100){if(m[1]&&!m[1].startsWith('#')){links.push({url:m[1],text:m[2].trim()});count++;}}extracted.push({url:result.url,success:true,runner:result.runner,data:{title,description,text_content:mainContent,links,meta:{text_length:mainContent.length,links_count:links.length}},timestamp:new Date().toISOString()});}catch(error){extracted.push({url:result.url,success:false,error:`Extraction failed: ${error.message}`,runner:result.runner});}}}return extracted.map(item=>({json:item}));"}, "name":"Extract & Clean Content (Safe)","type":"n8n-nodes-base.code","position":[2050,300]}, {"parameters":{"conditions":{"number":[{"value1":"={{$json.data?.text_length || 0}}","operation":"larger","value2":500}]}},"name":"Quality Check (500)","type":"n8n-nodes-base.if","position":[2250,300]}], "connections": {}}